{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Productivity versus Participation: Divergent Growth Paths in North America and East Asia\"\n",
        "author: \"Jackson Fang, Kei Nie, Felix Huang, Yunqing Chen\"\n",
        "format: \n",
        "   pdf:\n",
        "     fig-width: 3\n",
        "     fig-height: 2\n",
        "     margin: 1in\n",
        "engine: jupyter\n",
        "editor: \n",
        "   render-on-save: true\n",
        "---\n",
        "\n",
        "\n",
        "## Introduction\n",
        "\n",
        "Our study examines how labour-force utilization, income levels and short-run growth interact in two North-American economies—the United States and Canada—and two large East-Asian economies—China and Japan—during the period 1990 to 2023. 。。。\n",
        "\n",
        "## Data"
      ],
      "id": "953dbbc3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "! conda activate Python 3.11.5\n",
        "\n",
        "\n",
        "#| echo: false\n",
        "#| message: false\n",
        "import sqlite3\n",
        "import pandas as pd\n",
        "\n",
        "# open (or create) your SQLite database\n",
        "conn = sqlite3.connect('economic_data.db')\n",
        "\n",
        "# Cell 2 — Read each CSV and push to SQL as raw tables\n",
        "datasets = [\n",
        "    ('gdp',        '../data/gdp.csv'),\n",
        "    ('emp',        '../data/emp.csv'),\n",
        "    ('gdp_growth', '../data/gdp_growth.csv'),\n",
        "]\n",
        "\n",
        "for level, path in datasets:\n",
        "    print(f\"→ Loading raw table: {level}_raw from {path!r}\")\n",
        "    df = pd.read_csv(path, skiprows=4)  # adjust skiprows only if necessary\n",
        "    df.to_sql(f\"{level}_raw\", conn, if_exists='replace', index=False)\n",
        "\n",
        "print(\"All raw tables loaded into SQLite.\")\n",
        "\n",
        "import sqlite3\n",
        "\n",
        "# 1) Connect & get a cursor\n",
        "conn = sqlite3.connect('economic_data.db')\n",
        "cur  = conn.cursor()\n",
        "\n",
        "# 2) Define your filters (you may generate these programmatically, but we won't loop over tables)\n",
        "target_countries = ['China','Japan','South Korea','United States','United Kingdom','Canada']\n",
        "countries_sql = \", \".join(f\"'{c}'\" for c in target_countries)\n",
        "\n",
        "years    = [str(y) for y in range(1990, 2024)]\n",
        "columns  = ['Country Name', 'Indicator Name'] + years\n",
        "col_clause = \", \".join(f'\"{c}\"' for c in columns)\n",
        "\n",
        "# 3) Filter gdp_raw → gdp_filtered, drop old, rename\n",
        "cur.execute(f\"\"\"\n",
        "    CREATE TABLE gdp_filtered AS\n",
        "    SELECT {col_clause}\n",
        "      FROM gdp_raw\n",
        "     WHERE \"Country Name\" IN ({countries_sql});\n",
        "\"\"\")\n",
        "cur.execute(\"DROP TABLE gdp_raw;\")\n",
        "cur.execute(\"ALTER TABLE gdp_filtered RENAME TO gdp_raw;\")\n",
        "conn.commit()\n",
        "\n",
        "# 4) Filter emp_raw → emp_filtered, drop old, rename\n",
        "cur.execute(f\"\"\"\n",
        "    CREATE TABLE emp_filtered AS\n",
        "    SELECT {col_clause}\n",
        "      FROM emp_raw\n",
        "     WHERE \"Country Name\" IN ({countries_sql});\n",
        "\"\"\")\n",
        "cur.execute(\"DROP TABLE emp_raw;\")\n",
        "cur.execute(\"ALTER TABLE emp_filtered RENAME TO emp_raw;\")\n",
        "conn.commit()\n",
        "\n",
        "# 5) Filter gdp_growth_raw → gdp_growth_filtered, drop old, rename\n",
        "cur.execute(f\"\"\"\n",
        "    CREATE TABLE gdp_growth_filtered AS\n",
        "    SELECT {col_clause}\n",
        "      FROM gdp_growth_raw\n",
        "     WHERE \"Country Name\" IN ({countries_sql});\n",
        "\"\"\")\n",
        "cur.execute(\"DROP TABLE gdp_growth_raw;\")\n",
        "cur.execute(\"ALTER TABLE gdp_growth_filtered RENAME TO gdp_growth_raw;\")\n",
        "conn.commit()\n",
        "\n",
        "\n",
        "# 6) Verify first 5 rows of each\n",
        "for tbl in ['gdp_raw','emp_raw','gdp_growth_raw']:\n",
        "    print(f\"\\n--- {tbl} ---\")\n",
        "    cur.execute(f\"SELECT {col_clause} FROM {tbl} LIMIT 5;\")\n",
        "    rows = cur.fetchall()\n",
        "    # print column headers then rows\n",
        "    print(columns)\n",
        "    for row in rows:\n",
        "        print(row)\n",
        "\n",
        "# 7) Close connection\n",
        "conn.close()\n",
        "\n",
        "# Cell 3 — Reconnect to the database\n",
        "import sqlite3\n",
        "import pandas as pd\n",
        "\n",
        "conn = sqlite3.connect('economic_data.db')\n",
        "\n",
        "# Read all three tables back into pandas\n",
        "print(\"Reading tables into pandas DataFrames...\")\n",
        "gdp_df        = pd.read_sql_query(\"SELECT * FROM gdp_raw\", conn)\n",
        "emp_df        = pd.read_sql_query(\"SELECT * FROM emp_raw\", conn)\n",
        "gdp_growth_df = pd.read_sql_query(\"SELECT * FROM gdp_growth_raw\", conn)\n",
        "\n",
        "# Cell 4 — Data Cleaning\n",
        "print(\"\\nCleaning data...\")\n",
        "\n",
        "# Melt the dataframes (wide to long format) for easier merging later\n",
        "def melt_df(df, value_name):\n",
        "    id_vars = ['Country Name', 'Indicator Name']\n",
        "    value_vars = [col for col in df.columns if col not in id_vars]\n",
        "    return df.melt(id_vars=id_vars, value_vars=value_vars, \n",
        "                   var_name='Year', value_name=value_name)\n",
        "\n",
        "gdp_long        = melt_df(gdp_df, 'GDP')\n",
        "emp_long        = melt_df(emp_df, 'Employment')\n",
        "gdp_growth_long = melt_df(gdp_growth_df, 'GDP_Growth')\n",
        "\n",
        "# Make sure 'Year' is an integer and value columns are numeric\n",
        "def clean_numeric(df, value_col):\n",
        "    df['Year'] = df['Year'].astype(int)\n",
        "    df[value_col] = pd.to_numeric(df[value_col], errors='coerce')\n",
        "\n",
        "clean_numeric(gdp_long, 'GDP')\n",
        "clean_numeric(emp_long, 'Employment')\n",
        "clean_numeric(gdp_growth_long, 'GDP_Growth')\n",
        "\n",
        "# Cell 5 — Merge Tables Together\n",
        "print(\"\\nMerging datasets...\")\n",
        "\n",
        "merged_df = gdp_long.merge(emp_long,        on=['Country Name','Indicator Name','Year'], how='outer')\n",
        "merged_df = merged_df.merge(gdp_growth_long, on=['Country Name','Indicator Name','Year'], how='outer')\n",
        "\n",
        "# Because 'Indicator Name' can be different across tables, you can drop it after confirming\n",
        "merged_df.drop(columns=['Indicator Name'], inplace=True)\n",
        "\n",
        "# Optional: Reorder columns\n",
        "merged_df = merged_df[['Country Name', 'Year', 'GDP', 'Employment', 'GDP_Growth']]\n",
        "\n",
        "# Cell 6 — Save Cleaned DataFrame into SQL\n",
        "print(\"\\nSaving merged cleaned data into database as 'econ_cleaned'...\")\n",
        "\n",
        "merged_df.to_sql('econ_cleaned', conn, if_exists='replace', index=False)\n",
        "\n",
        "\n",
        "# Cell 7 — Descriptive Statistics Summary\n",
        "print(\"\\nGenerating summary statistics...\")\n",
        "\n",
        "summary_stats = merged_df.groupby('Country Name').agg({\n",
        "    'GDP': ['count', 'mean', 'std', 'min', 'max'],\n",
        "    'Employment': ['count', 'mean', 'std', 'min', 'max'],\n",
        "    'GDP_Growth': ['count', 'mean', 'std', 'min', 'max'],\n",
        "})\n",
        "\n",
        "# Clean up column names\n",
        "summary_stats.columns = ['_'.join(col).strip() for col in summary_stats.columns.values]\n",
        "\n",
        "# Display\n",
        "print(summary_stats)\n",
        "\n",
        "# Optional: Save summary statistics to a CSV\n",
        "summary_stats.to_csv('summary_statistics.csv')\n",
        "\n",
        "# Final Step — Close connection\n",
        "conn.close()\n",
        "\n",
        "print(\"\\nAll tasks completed!\")"
      ],
      "id": "f072a3f9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Income levels and their growth paths Income levels and their growth paths\n"
      ],
      "id": "71d4215a"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| echo: false\n",
        "# ============== 0.  SETUP ====================================================\n",
        "\n",
        "!pip install pycountry\n",
        "!pip install statsmodels\n",
        "\n",
        "import sqlite3\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from pathlib import Path\n",
        "import pycountry                     # pip install pycountry\n",
        "\n",
        "# ---- output folders ---------------------------------------------------------\n",
        "OUT_FIG = Path(\"figures\")\n",
        "OUT_DAT = Path(\"processed\")\n",
        "OUT_FIG.mkdir(exist_ok=True, parents=True)\n",
        "OUT_DAT.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "INDICATORS = [\"GDP\", \"Employment\", \"GDP_Growth\"]\n",
        "\n",
        "# ============== 1.  LOAD CLEAN PANEL =========================================\n",
        "DB_PATH = \"/Users/chenyunqing/Documents/QTM350/QTM350-GDP-Project/350FinalQuarto/economic_data.db\"\n",
        "with sqlite3.connect(DB_PATH) as con:\n",
        "    df = pd.read_sql_query(\"SELECT * FROM econ_cleaned\", con)\n",
        "\n",
        "if df.empty:\n",
        "    raise RuntimeError(\"econ_cleaned table is empty – check SQL pipeline.\")\n",
        "\n",
        "# ============== 2.  ENRICH  – add ISO-3 codes  ===============================\n",
        "def name_to_iso3(name):\n",
        "    try:\n",
        "        return pycountry.countries.lookup(name).alpha_3\n",
        "    except LookupError:\n",
        "        # handle special cases\n",
        "        mapping = {\n",
        "            \"South Korea\": \"KOR\",\n",
        "            \"United States\": \"USA\",\n",
        "            \"United Kingdom\": \"GBR\"\n",
        "        }\n",
        "        return mapping.get(name, None)\n",
        "\n",
        "df[\"iso3\"] = df[\"Country Name\"].apply(name_to_iso3)\n",
        "if df[\"iso3\"].isna().any():\n",
        "    missing = df[df[\"iso3\"].isna()][\"Country Name\"].unique()\n",
        "    raise ValueError(f\"ISO-3 lookup failed for: {missing}\")\n",
        "\n",
        "# ============== 3.  BASIC CLEANING ===========================================\n",
        "df[INDICATORS] = df[INDICATORS].apply(pd.to_numeric, errors=\"coerce\")\n",
        "\n",
        "# forward-fill within each country to patch occasional NaNs\n",
        "df = (df.sort_values([\"iso3\", \"Year\"])\n",
        "        .groupby(\"iso3\")\n",
        "        .apply(lambda g: g.ffill())\n",
        "        .reset_index(drop=True))"
      ],
      "id": "bbd0fa87",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "def lineplot(ind_col, ylab):\n",
        "    plt.figure()\n",
        "    for iso, g in df.groupby(\"iso3\"):\n",
        "        plt.plot(g[\"Year\"], g[ind_col], label=iso)\n",
        "    plt.title(ylab)\n",
        "    plt.xlabel(\"Year\")\n",
        "    plt.ylabel(ylab)\n",
        "    plt.legend()\n",
        "    plt.tight_layout()\n",
        "    plt.savefig(OUT_FIG / f\"{ind_col}_trend.png\", dpi=300)\n",
        "    plt.plot()\n",
        "\n",
        "lineplot(\"GDP\",         \"GDP per capita (constant 2015 US$)\")\n",
        "lineplot(\"GDP_Growth\",  \"GDP growth rate (%)\")\n",
        "lineplot(\"Employment\",  \"Employment-to-population 15+ (%)\")"
      ],
      "id": "3aa812c4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The GDP-per-capita plot underscores the prosperity gap that separates North America from East Asia. Real income in the United States rises from roughly thirty-nine thousand dollars in 1990 to about sixty-six thousand in 2023, widening its lead over all other cases. Canada mirrors the American path but remains seven to ten thousand dollars lower throughout. China, starting from a base of just over one thousand dollars, multiplies its income almost ten-fold, yet still reaches only about twelve thousand dollars by the end of the sample. Japan’s income climbs during the 1990s but plateaus at approximately thirty-six thousand dollars after 2010. The corresponding growth-rate figures reveal that China’s rapid expansion, once firmly in double digits, decelerates to mid-single-digit territory in the 2010s. Japan’s growth oscillates around zero, reflecting its long struggle with deflation and demographic ageing. The United States and Canada exhibit more moderate booms and busts, rarely exceeding four percent on the upside or falling much below minus two percent except in the global crises of 2009 and 2020, which strike all four economies simultaneously.\n",
        "\n",
        "\n",
        "\n",
        "## Quarto\n",
        "\n",
        "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>."
      ],
      "id": "392cf11a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "quiz_env",
      "language": "python",
      "display_name": "Python 3.10 (quiz_env)",
      "path": "/Users/chenyunqing/Library/Jupyter/kernels/quiz_env"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}